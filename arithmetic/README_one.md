<!--
 * @Author: TerryMin
 * @Date: 2022-06-16 09:35:23
 * @LastEditors: TerryMin
 * @LastEditTime: 2023-04-06 20:19:31
 * @Description: file not
-->

# 数据结构

[个人算法博客总结](https://i.cnblogs.com/tags/posts?tagId=4241828)

一 数据结构:数据结构是计算机存储、组织数据的方式。数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装

我们每天的编码中都会用到数据结构，因为数组是最简单的内存数据结构，下面是常见的数据结构:

1. 数组（Array）
2. 队列（Queue）：是一种特殊的线性表；特殊之处在于它只允许在表的前端（front）即队头 进行删除操作，而在表的后端（rear）即队尾 进行插入操作，和栈一样，队列是一种操作受限制的线性表。即先进先出（FIFO）。（银行窗口排队例子）
3. 栈（Stack）：栈是一种遵从先进后出 (LIFO) 原则的有序集合；在栈顶进行 元素的添加或者删除，另一端为栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。(堆叠的盘子例子)。
4. 堆（Heap）：存放引用类型（如对象、数组、函数等），值大小不固定，栈内存中存放的地址指向堆内存中的对象； 堆是一种二叉树结构。它的存取数据的方式与书架非常相似。堆的特点是以“键值对”存储方式，存取方式与顺序无关。
5. 链表（Linked List）
6. 树（Tree）
7. 图（Graph）
8. 散列表（Hash）
   其中，栈和队列是一种类似数组的数据结构，它们之间的区别仅仅体现在数据项的插入和移除的方式上。链表、树和图则是另一种节点与节点之间维持引用关系的数据结构。散列表（也称哈希表）依赖散列函数来保存和定位数据。

就复杂性而言，栈和队列是最简单的两种，并且二者都可以通过链表来进行构造。树和图则是最复杂的，因为它们继承了链表的概念。散列表需要利用这些数据结构来可靠地执行。就执行效率而言，链表在对数据的记录和排序上表现最好，同时散列表也更加擅长查找和提取数据。

二 JavaScript 数据结构：

- 栈内存：存放基本数据类型,是大小固定并且有序的,按值访问。javaScript 中，数据类型分为基本数据类型和引用数据类型，基本数据类型七种包含：null、undefined、string、number、boolean、symbol、bigint 这几种。

- 堆内存：一般由操作人员（程序员）分配释放，若操作人员不分配释放，将由 OS（操作系统）回收释放。分配方式类似链表。堆存储在二级缓存中。JavaScript 的数据类型除了原始类型，还有一类是 Object 类型，它包含：

Object
Function
Array
Date
RegExp

三 数据结构分类：

- 线性结构： 数据元素之间是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的有序数据元素的集合。常用的线性结构有：线性表，栈，队列，双队列，数组，串。

- 非线性结构：各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系（例如：球形，网型）。根据关系的不同，可分为层次结构和群结构。常见的非线性结构有：二维数组，多维数组，广义表，树(二叉树等)，图。（其中多维数组是由多个一维数组组成的，所以不再是线性结构）

[JS 数据结构分类](https://blog.csdn.net/huangpb123/article/details/103645846)

四 链表

1. 链表:

线性表（线性存储结构）：把所有数据用一根线串起来，再存储到物理空间中。存储的是具有“一对一”关系的数据元素的集合。

线性表常用术语：
某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；
某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；
链表类型：
顺序表：将数据依次存储在连续的整块物理空间中。顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，具有“一对一”特性。
链表：数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系。利用指针访问。

2. 链表分类：JS 实现链表

单向链表：用于存储逻辑关系为 "一对一" 的数据。与顺序表不同，链表不限制数据的物理存储状态，即使用链表存储的数据元素，其物理存储位置是随机的。
双向链表：

单向循环链表

双向循环链表

[链表的实现与应用](https://www.cnblogs.com/jaxu/p/11277732.html)

五 树:

1. 树相关术语：（https://juejin.im/post/5ad56de7f265da2391489be3#heading-2）
   根结点是树最顶层结点
   边是两个结点之间的连接
   子结点是具有父结点的结点
   父结点是与子结点有连接的结点
   叶子结点是树中没有子结点的结点（树得末端）
   高度是从下往上数。
   深度是从根节点往下层级。
   节点的度：节点拥有的子树的个数。

2. 二叉树（Binary tree）：指树中的节点最多只能有两个子节点，一个是左子节点，一个是右子节点。左右子节点的顺序不能颠倒。即二叉树中不存在度大于 2 的节点树。二叉树的遍历有两种选择：

- 深度优先搜索（Depth-First Search，DFS）：（前中后序是相对根节点而言）广度优先算法实践
  前序遍历：根节点优先，之后是左节点，最后是右节点。
  中序遍历：左节点优先，之后是根节点，最后是右节点。
  后序遍历：左节点优先，之后是右节点，最后是根节点。
- 广度优先搜索（Breadth-First Search，BFS）：BFS 是一层层逐渐深入的遍历算法

3. 二叉搜索树（BST——Binary Search Tree）是二叉树的一种，它规定在左子节点上存储小（比父节点）的值，在右子节点上（比父节点）存储大（或等于）的值。
   自平衡二叉搜索树（AVL——Adelson-Velskii-Landi）。在 AVL 中，任何一个节点左右两棵子树的高度之差最多为 1，添加或移除节点时，AVL 树会尝试自平衡。对 AVL 树的操作和对 BST 树的操作一样，不同点在于我们还需要重新平衡 AVL 树
   红黑树也是一种自平衡二叉搜索树，但是它对其中的节点做了很多特殊的规定，使得在操作树节点的性能上要优于 AVL。

[JS 树的实现](https://www.cnblogs.com/jaxu/p/11309385.html)
